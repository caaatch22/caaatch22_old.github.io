<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++内存模型 —— 现代Architecture的妥协</title>
    <link href="/C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E2%80%94%E2%80%94-%E7%8E%B0%E4%BB%A3Architecture%E7%9A%84%E5%A6%A5%E5%8D%8F/"/>
    <url>/C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E2%80%94%E2%80%94-%E7%8E%B0%E4%BB%A3Architecture%E7%9A%84%E5%A6%A5%E5%8D%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="../img/memory-model/title-graph.png" alt="一本简单介绍内存一致性的书" /></p><ol><li>优化，引出内存模型；程序的执行顺序。</li><li>C++内存模型，atomic相关（cppcon介绍）</li><li>TSO等</li></ol><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>什么是内存模型(Memory Model)呢？这里介绍的内存模型并非<a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=160489e8b12cd9a44cbff0cd85fb6aa05437d1ac">C++对象的内存排布模型</a>，而是一个非编程语言层面的概念。我们知道在C++11中，标准引入了 <code>std::atomic&lt;&gt;</code>原子对象，同时还引入了</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">memory_order_relaxed<br>memory_order_consume<br>memory_order_acquire<br>memory_order_release<br>memory_order_acq_rel<br>memory_order_seq_cst<br></code></pre></td></tr></table></figure><p>这六种 <code>memory order</code>。引入可以让我们进行<strong>无锁编程</strong>，而如果你想要更高性能的程序，你就必须深挖这六种内存模型的含义并正确应用。（当然，在不显式指明memory order的情况下，你能保证获得正确的代码，但存在性能损失）</p><h2 id="内存模型"><a class="markdownIt-Anchor" href="#内存模型"></a> 内存模型</h2><p>在介绍C++ memory order之前，我们先回答另一个问题。<em>你的计算机执行的程序就是你写的程序吗? —— 显然不是的。</em></p><p>原因也很简单，为了更高效的执行指令，编译器、CPU结构、缓存及其他硬件系统都会对指令进行增删，修改，重排。但要回答具体进行了什么样的修改，又是一个极其复杂的问题。或者说，整个现代体系结构，就是在保证程序正确性的前提下利用各种手段对程序优化。我们可以粗略的将其分成几个部分：</p><ol><li><strong>source code order:</strong> 程序员在源代码中指定的顺序</li><li><strong>program code order:</strong> 基本上可以看成汇编/机器码的顺序，它可以由编译器优化后得到</li><li><strong>execution code order:</strong> CPU执行指令顺序也不见得与汇编相同，不同CPU在执行相同机器码时任然存在优化空间。</li><li><strong>perceived order/physical order:</strong> 最终的执行顺序。即便CPU按照某种确定指令执行，物理时间上的执行顺序仍然可能不同。例如，在超标量CPU中，一次可以fetch and decode多个指令，这些指令之间的物理执行顺序就是不确定的；由于不同层级缓存之间延时不同，以及缓存之间的通信需要等带来的不确定的执行顺序等</li></ol><p><img src="../img/memory-model/optimization-by-different-parts-of-computer.png" alt="optimizations-by-compyter" /></p><p>上图简要说明了你的源代码可能经历的优化步骤。</p><p>这些优化的一个主要原因在于 掩盖memory access操作与CPU执行速度上的巨大鸿沟。如果没有cache，CPU每个访存指令都需要stall一两百个时钟周期，这是不可接受的。但是引入cache的同时又会带来 <code>cache coherence</code>等问题，这也是造成x初始为0，两个线程同时执行 <code>x++</code>，而x最终不一定为 <code>2</code>的元凶。<strong>而一个内存模型则对上述并发程序的同一块内存进行了一定的限制，它给出了在并发程序下，任意一组写操作时，可能读到的值。</strong> 不同体系结构(x86, arm, power…)通过不同的内存模型来保证程序的正确性。</p><blockquote><p>bonus question: 不同等级的cache latency？<br />answer: l1: 1ns, l2: 5ns, l3: 50~100ns, main memory: 200ns</p></blockquote><h3 id="sequential-consistencysc"><a class="markdownIt-Anchor" href="#sequential-consistencysc"></a> Sequential Consistency(SC)</h3><p>SC是最严格的内存模型，也被称作non-weak memory model。在该模型下，多线程程序执行的可做如下分析：对于每一步，随机选择一个线程，并执行该线程执行中的下一步（例如，按程序或编译的顺序）。重复这个过程，直到整个程序终止。这实际上等效于按照（程序或编译的）顺序执行所有线程的所有步骤，并以某种方式交错它们，从而产生所有步骤的单一总顺序。SC不允许重新排列线程的步骤。因此，每当访问对象时，都会检索该顺序中存储在对象中的最后一个值。（注意，内存模型中说的重新排列与编译器层面无关，编译器自然是可以讲没有data dependance的读写操作进行重排的，只要保证程序的正确性即可。内存模型中的重排指的是在硬件执行阶段，由于cache hierarchy等引发的一些问题导致指令物理执行顺序被改变）。</p><p>也就是说，我们可以抽象出一个简单的内存结构：<br /><img src="../img/memory-model/SC-model.png" alt="SC-model" /><br />在这种结构中，我们隐藏了cache与store buffer的存在，或者说SC协议允许我们无视这两个硬件。<br />那么，我们对于下面表格中的问题就有确定的答案：</p><table><thead><tr><th>Thread 1</th><th>Thread 2</th><th>main</th></tr></thead><tbody><tr><td>x = 1 <code>&lt;br&gt;</code> y’ = y</td><td>y = 1 <code>&lt;br&gt;</code> x’ = x</td><td>x = 0 <code>&lt;br&gt;</code> y = 0 <code>&lt;br&gt;</code> Spawn thread 1, 2 <code>&lt;br&gt;</code> Wait for threads</td></tr></tbody></table><p>显然，在SC模型中最终的结果只可能是：</p><ol><li>x = 1, y = 1;</li><li>x = 0, y = 1;</li><li>x = 1, y = 0;</li></ol><p>而不会出现 x = 0; y = 0的情况。</p><h3 id="x86-tso"><a class="markdownIt-Anchor" href="#x86-tso"></a> x86-TSO</h3><p>x86-TSO(Total Store Order)，它比SC更<em>弱</em>，但仍是现代CPU的约束最强的内存模型其中之一。tso的架构可以用以下抽象来代替：<br /><img src="../img/memory-model/TSO-model.png" alt="TSO-model" /><br />注意，这并非真实的x86的架构(毕竟连cache都没有)，只是x86-tso模型保证我们得到这样的抽象。这里的store buffer(或者叫write buffer)也不一定对应着硬件上的store buffer。它也可以是cache hierarchy的一部分，他们之间有一致性协议进行约束来保证上图中的效果。</p><p>TSO模型最重要的几个特性：</p><ul><li>store buffer是FIFO的，读取线程必须读取其自身最近缓冲的写操作，如果有的话，读取的地址与该写操作一致。否则，读取操作将从共享内存中满足。</li><li>mfence 指令会清空该hardware thread的store buffer</li><li>要执行一个带锁的指令，线程必须首先获取全局锁。在指令结束时，它会清空自己的store buffer并释放锁。当一个线程持有锁时，其他线程无法读取。这基本上意味着带锁的指令强制实现了顺序一致性。</li><li>线程的可以在任何时间传播到共享内存中，除非另一个线程持有锁。</li></ul><p>在TSO下，对于上述表格中的问题，则可能出现 <code>x = 0, y = 0</code>的结果：<code>x = 1</code>与 <code>y = 1</code>都被放到store buffer上而未被flush到shared memory中。</p><p>也就是说：<br />x86-TSO does not permit local reordering except of <strong>reads after writes to different addresses.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assemble">thread 1, thread 2    可能会     thread 1, thread 2<br>write a,  write b    ————————&gt;   read b,   read a<br>read b,   read a                 write a,  write b<br></code></pre></td></tr></table></figure><p>要解决这个问题也很简单，在write后加上mfence指令即可，它会将store buffer中的存储刷到shared memory中。<br />这也是TSO比SC理论性能更高的原因，它舍弃了一定的正确性，来减少每次写操作都flush store buffer的开销。</p><blockquote><p>fun fact: intel和amd从没承认过他们的x86一定符合x86-tso内存模型，但是他们进行过黑盒测试，结果证明了这一点。（就连设计者都无法reason出理论上的结果，而是通过测试证明的）</p></blockquote><h3 id="arm-and-power"><a class="markdownIt-Anchor" href="#arm-and-power"></a> ARM and POWER</h3><p>Arm and power则有着更加宽松的内存模型。为了理解这样一台机器的行为，我们可以认为每个hardware thread都拥有自己的内存副本，如下图所示。所有内存副本和它们的interconnection（即除了线程以外的一切）的集合通常被称为<em>storage subsystem</em>。一个线程的写操作可能以<strong>任何顺序</strong>传播到其他线程，并且不同地址的写操作的传播可以任意交错，除非它们受到屏障或缓存一致性的限制。也可以将屏障视为从执行它们的硬件线程传播到每个其他线程的操作。<br /><img src="../img/memory-model/ARM-model.png" alt="Arm-Model" /></p><p>由于每个线程都有自己的子存储系统，它们之间的同步就需要fence进行保障。ARM和POWER提供了barrier(fence)指令(分别是<code>dbm</code> 和 <code>sync</code>)来约束下面几种顺序：</p><ol><li>Read/Read之间fence:保证他们按照program<br />order执行</li><li>Read/Write屏障: 确保在写操作被提交（因此传播并对其他人可见）之前，读操作被满足并提交。</li><li>Write/Write屏障：确保第一个写操作在第二个写操作被提交之前被提交并传播到所有其他线程。</li><li>Write/Read屏障：确保在读操作被满足之前，写操作已被提交并传播到所有其他线程。<br />POWER架构还提供了一个额外的“轻量级同步”指令，称为<code>lwsync</code>，它比sync指令更弱，也因此可能更快。具体作用不在此处赘述。</li></ol><p>除了屏障之外，这些体系结构还提供以下依赖关系来强制顺序：</p><ul><li>Address dependency：当第一条指令读取的值用于计算第二条指令的地址时，从一个读操作到程序顺序后的读或写之间存在地址依赖。</li><li>Control dependency：当第一条指令读取的值用于计算在第二条指令之前的程序顺序条件分支的条件时，从一个读操作到程序顺序后的读/写之间存在控制依赖。</li><li>Data dependency：当第一条指令读取的值用于计算由第二条指令写入的值时，从一个读操作到程序顺序后的写之间存在数据依赖。</li></ul><p>在ARM和POWER处理器中，read-to-read的control dependency力度较小，因为它们可以在条件分支之前进行推测性执行，从而在第一次读取之前满足第二次读取。为了增加read-to-Read的控制依赖的影响力，可以在条件分支和第二次读取之间添加一个ISB（ARM）或isync（POWER）指令。<br />相反，read-to-write的control dependency具有一定的影响力：在分支被提交之前，写操作不会被其他任何线程看到，因此也不会在第一次读取的值固定之前被看到。<br />总结一下，从一个读取到另一个读取，如果存在address dependency 或带有 ISB/isync 的控制依赖，将阻止第二个读取在第一个读取之前被满足，而纯粹的control dependency则不会。从读取到写入，地址、控制或数据依赖都将阻止写入在读取的值固定之前对任何其他线程可见。</p><h2 id="c-memory-order"><a class="markdownIt-Anchor" href="#c-memory-order"></a> C++ memory order</h2><p>对于<code>weak memory model</code>，特别是上面介绍的Arm的内存模型，想要精细的控制程序的允许重排的程度需要非常大的心智负担。（光是不同体系结构，不同等级的fence指令就令人望而却步）。因此C++11标准提供的六种memory order就是从语言层面来约束最终希望达到的对程序被优化程度的限制。现在我们再看这几种memory order就比较清晰了。（以下说法并不严谨，但是作为程序员的take away完全足够了。</p><table><thead><tr><th>Memory Order</th><th>Explaination</th></tr></thead><tbody><tr><td>memory_order_relaxed</td><td>表示这个R/W操作除了原子性外没有任何其他限制，他可能会被重排到程序的任何位置（当然，编译器不会允许将他重排到同一个线程对同一个原子变量写操作的前面，这违背了正确性）</td></tr><tr><td>memory_order_consume</td><td>(只用于读) 后面依赖此原子变量的访存指令不允许重排至此条指令之前。 注意，当前标准中的memory_order_consume是<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r0.html%E6%89%80%E4%BB%A5%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8">没有实际用处的</a>， 一般情况下不要使用</td></tr><tr><td>memory_order_acuqire</td><td>(只用于读) 后面访存指令不允许重排至此条指令之前</td></tr><tr><td>memory_order_release</td><td>(只用于写) 前面访存指令不允许重排至此条指令之后。当此条指令的结果对其他线程可见后，之前的所有指令都可见</td></tr><tr><td>memory_order_acq_rel</td><td>acquire + release语意</td></tr><tr><td>memory_order_seq_cst</td><td>满足sequential_consistency内存模型</td></tr></tbody></table><p><img src="../img/memory-model/acquire-barrier.png" alt="acuire barrier" /></p><p>在默认情况下，<code>std::atomic&lt;&gt;</code>相关函数总是选用<code>std::memory_order_seq_cst</code>，它能有效地帮我们避免错误。但是，我们既然都使用atomic而不是mutex了，自然是对性能有很高的要求。<br /><img src="../img/memory-model/memory-barriers-performance.png" alt="memory barriers and performance" />，从上图中可以看出，<code>memory_order_relaxed</code>的行呢个和<code>non-atomic</code>几乎没有差别，而<code>seq_cst</code>则要慢许多。</p><p>如果上面的表格看起来还是有点抽象，我们举几个常用的例子进行说明：</p><h3 id="relax-model"><a class="markdownIt-Anchor" href="#relax-model"></a> relax-model</h3><h3 id="release-acuqire-model"><a class="markdownIt-Anchor" href="#release-acuqire-model"></a> release-acuqire model</h3><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><ol><li><p>你可能已经注意到了，X86-TSO内存模型非常严格，它已经为我们提供了</p><ul><li>all load are acquire-loads, all stores are release-stores</li><li>all read-modify-write operations are acquire-release<br />也就是说x86平台下不存在真正的memory-order-relexed</li></ul></li><li></li></ol><p>关于 <code>std::atomic&lt;&gt;</code>，</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++ memory order</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>parallel-hashmap</title>
    <link href="/parallel-hashmap/"/>
    <url>/parallel-hashmap/</url>
    
    <content type="html"><![CDATA[<h1 id="phmap_map"><a class="markdownIt-Anchor" href="#phmap_map"></a> phmap_map</h1><blockquote><p>众所周知，C++标准库的 <code>unordered_map</code>向来不是一个好的选择。开源市场上有非常多的高性能哈希表可供选择，<a href="https://github.com/greg7mdp/parallel-hashmap">phmap</a>继承自 <code>absl-hashmap</code>，有着非常好的插入、查找性能。在著名的<a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/#benchmark-results-table">Comprehensive C++ Hashmap Benchmarks 2022</a>榜单中名列前茅。事实上，我比对了 <code>phmap::flat_hash_map</code>与榜单中综合性能第一的 <code>ankerl::unordered_dense::map</code>，我的benchmark中只有遍历哈希表时，<code>flat_hash_map</code>的性能低于 <code>unordered_dense::map</code>，其余无论是插入还是随即查找，大部分情况下 <code>flat_hash_map</code>的性能都更优。本文简单介绍了 <code>flat_hash_map</code>相关情况，以及一些使用上的建议与坑点。</p></blockquote><h3 id="flat_hash_map-和-node_hash_map区别"><a class="markdownIt-Anchor" href="#flat_hash_map-和-node_hash_map区别"></a> flat_hash_map 和 node_hash_map区别</h3><p>phmap中有提供了两类哈希表，其内部布局示意图如下：</p><img src="../img/phmap/flat_hash_map-vs-node_hash_map.png" width="700" height="400" align=center/><p>由上图（忽略了bucket的细节）可以看出，<code>flat_hash_map</code>的最大的优点在于</p><ol><li>node之间的内存是连续的(虽然可能中间存在空node)，遍历的时候对cache更加友好</li><li>并且相比于 <code>node_hash_map</code>版少一次寻址过程（<code>std::unordered_map</code>的设计与 <code>node_hash_map</code>）相同。</li></ol><p>而 <code>flat_*</code>系列的缺点就是在 <code>rehash</code>的时候:</p><ol><li>会引发原来的value<strong>失效</strong>（这里的失效指的是原来的那个对象所对应的内存失效，而不是value所包含的内容失效，例如，value是一个指针，那它的值——所指向的对象，不会受到影响）。举个例子：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br>flat_hash_map&lt;<span class="hljs-type">int</span>, Data&gt; mp;<br>node_hash_map&lt;<span class="hljs-type">int</span>, Data&gt; nodemp;<br>mp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Data</span>();<br>nodemp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Data</span>();<br><span class="hljs-keyword">auto</span>&amp; mp0 = mp[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">auto</span>&amp; nodemp0 = nodemp[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// tigger rehash</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i ++) &#123;<br>  mp[i] = <span class="hljs-built_in">Data</span>();<br>  nodemp[i] = <span class="hljs-built_in">Data</span>(); <br>&#125;<br><span class="hljs-built_in">assert</span>(std::<span class="hljs-built_in">addressof</span>(mp[<span class="hljs-number">0</span>]) != std::<span class="hljs-built_in">addressof</span>(mp0));<br><span class="hljs-built_in">assert</span>(std::<span class="hljs-built_in">addressof</span>(nodemp[<span class="hljs-number">0</span>]) == std::<span class="hljs-built_in">addressof</span>(nodemp0));<br><br></code></pre></td></tr></table></figure><p>原因就是 <code>flat_hash_map</code>的内存布局导致的。而 <code>node_hash_map</code>或者 <code>std::unordered_map</code>就保证不会出现这种情况，因为当他们rehash的时候，只需要将bucket内的指针重新分配，指针的值还是指向原来的 <code>node&lt;key, value&gt;</code>.</p><ol start="2"><li>由上述原因引发的性能问题： 当 <code>node&lt;pair, value&gt;</code>很大的时候，<code>flat_hash_map</code>每次 rehash 需要重新构造的开销大，而 <code>node_hash_map</code>只需要重新构造相同数量的指针。并且遍历时也因为两个node之间相隔较大使得 cache locality 下降。</li></ol><h3 id="使用建议单线程"><a class="markdownIt-Anchor" href="#使用建议单线程"></a> 使用建议(单线程)</h3><p>绝大多数情况下直接用 <code>flat_hash_map</code>:</p><ol><li><code>int -&gt; int</code></li><li><code>int -&gt; string</code></li><li><code>string-&gt;int</code></li><li><code>string(sso) -&gt; string(sso)</code></li><li><code>string(none-sso)-&gt;string(none-sso)</code></li></ol><p>少数情况用 <code>node_hash_map</code>:</p><ol><li><p><code>key -&gt; Large Data</code></p><p>这种情况强烈建议用 <code>flat_hash_map&lt;key, ptr&lt;Large Data&gt;&gt;</code>代替</p></li></ol><p>有意思的一点是为什么经过实测 <code>string(none-sso) -&gt; string(none-sso)</code>这种情况下仍然是 <code>flat_hash_map</code>更快一点，难道string(none-sso)不是Large Data吗？</p><p>事实上，<code>string</code> 虽然可能很大，但是其 <code>raw data</code>存在另外分配的一个空间（超过短字符串优化限定大小时），所以当rehash的时候，新生成的string只需要move由来的string就可以了。下图展示了其内存布局：</p><img src="../img/phmap/flat_map_string_nonesso.png" width="400" height="600" align=center/><p><strong>另外，如果提前知道需要插入的pair的数量（或者大致数量），特别是只作为一个look-up table使用时（一次性插入，只查询或更改已存在的key），那么使用提前 <code>reverse</code>是个明智的选择，这能有效提高哈希表的性能。一般需要reserve成需要插入数量的 <em>两倍</em> 而不是一倍 ，因为与vector这样的容器不同的是，为了防止过于频繁的碰撞，会在每个bucket还没满的时候就进行扩容</strong></p><h3 id="parallel_flat_hash_map"><a class="markdownIt-Anchor" href="#parallel_flat_hash_map"></a> parallel_flat_hash_map</h3><p><code>phmap</code>库除了包含继承自 <code>abseil</code>的 <code>&#123;flat/node&#125;_hash_&#123;set/map&#125;</code>外，还有支持并发操作下的 <code>parallel_*</code>系列。以 <code>parallel_flat_hash_map</code>为例，其实现如下图：</p><img src="../img/phmap/parallel_hash_map.png" width="550" height="400" align=center/><p>一个 <code>parallel_flat_hash_map</code>有（默认 2^4 = ）16 个 <code>子flat_hash_map</code>组成。这样做可以</p><ol><li>更加细粒度的使用锁，从而减少锁之间的等待</li><li>一次rehash一个 <code>submap</code>，减小修改操作的开销</li></ol><p>基本的使用方法也很简单，需要在模板参数上指定一个锁，一般使用（std::mutex或者std::shared_mutex，官方文档说shared_mutex性能更优，我个人的测试下mutex性能更优，但是相差不大）。其余的使用上与非parallel版本基本一致，以下是简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 前两个模板参数是key, value，最后两个模板参数是 N (2^N表示子map的数量， N默认为4)， 和指定的锁</span><br>  phmap::parallel_flat_hash_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>,<br>    phmap::priv::hash_default_hash&lt;<span class="hljs-type">int</span>&gt;,<br>    phmap::priv::hash_default_eq&lt;<span class="hljs-type">int</span>&gt;,<br>    phmap::priv::Allocator&lt;std::pair&lt;constint, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-number">4</span>, std::mutex&gt;<br>  para_mp;<br>para_mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>para_mp.<span class="hljs-built_in">subcnt</span>(); <span class="hljs-comment">// return sub map count</span><br></code></pre></td></tr></table></figure><p>经过测试，在插入和修改操作混合的情况下（随机插入1000000个数，非重复数字在600000以上），<code>parallel_mp</code>耗时 <code>80ms</code>左右，而手动给 <code>flat_hash_map</code>加锁耗时 <code>250ms</code>左右。</p><p><strong>另外</strong>，既然 <code>parallel_*</code>是由多个子map形成，那个在特定条件下，我们甚至可以无需锁就能保证线程安全。</p><p>具体操作如下：</p><ol><li>已知所有的需要插入的key</li><li>每个线程需要有一个线程idx标识，线程数量少于 <code>子map</code>数量</li><li>对于特定的key，得到hashval后将这个key的所有相关操作绑定到某个特定线程上进行。</li></ol><p>这样就可以实现无锁并发</p><p>我们可以通过下面这个例子具体观察：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">using</span> para_mp = parallel_flat_hash_map&lt;K, V&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> keys = <span class="hljs-built_in">random_vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, n);<br><span class="hljs-type">constexprint64_t</span> num_threads = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">auto</span> thread_fn = [&amp;num_threads](para_mp&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; mp, vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-type">const</span>&amp; keys,<br>                    <span class="hljs-type">int</span> thread_idx) &#123;<br>  <span class="hljs-type">size_t</span> modulo = mp.<span class="hljs-built_in">subcnt</span>() / num_threads;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int64_t</span> i = <span class="hljs-number">0</span>; i &lt;keys.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-type">int</span> key = keys[i];<br>    <span class="hljs-type">size_t</span> hashval = mp.<span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-type">size_t</span> idx = mp.<span class="hljs-built_in">subidx</span>(hashval);<br>    <span class="hljs-keyword">if</span> (idx / modulo ==<br>        thread_idx)  <span class="hljs-comment">// if the submap is suitable for this thread</span><br>    &#123;<br>      mp[key] = <span class="hljs-built_in">rng</span>();  <span class="hljs-comment">// insert random value</span><br>    &#125;<br>  &#125;<br>&#125;;<br>std::unique_ptr&lt;std::thread&gt; threads[num_threads];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; i++) &#123;<br>  threads[i].<span class="hljs-built_in">reset</span>(<br>      newstd::<span class="hljs-built_in">thread</span>(thread_fn, std::<span class="hljs-built_in">ref</span>(mp), std::<span class="hljs-built_in">cref</span>(keys), i));<br>&#125;<br>timer.<span class="hljs-built_in">reset</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int64_t</span> i =<span class="hljs-number">0</span>; i &lt; num_threads; ++i)<br>  threads[i]-&gt;<span class="hljs-built_in">join</span>();<br><br></code></pre></td></tr></table></figure><p>上面的代码基本展示了无锁使用 <code>parallel_*</code>的过程，我们会将hashval按照 submap 进行区分，如果 <code>idx = mp.subidx(hashval)</code> 表示这个key对应的 submap。在上述代码中，一个线程对应两个 submap可以进行插入。</p><p>这种用法的局限性也很明显：线程数量需要是 submap 数量的倍数；一个线程一定要对应一个下标传入需要处理的函数；总之不是很好用…</p><p>（在多线程下只用map更加有效的方法或许是对于不同的key直接用不同的线程进行处理，且提前reserve防止rehash的时候迭代器失效）</p><h3 id="benchmarks"><a class="markdownIt-Anchor" href="#benchmarks"></a> benchmarks</h3><p>以下操作的个数都为 <code>1'000'000</code>次，最后一列string-&gt;string 插入次数为 <code>100'000</code>次</p><p><em>vector作为baseline插入pair&lt;K,V&gt;进行比较</em></p><table><thead><tr><th>benchmarks(insert)</th><th>insert ints</th><th>insert ints(reserve first)</th><th>insert string(sso)-&gt;ptr</th><th>insert int-&gt;LargeData</th><th>insert string(8)-&gt;string(4096)</th></tr></thead><tbody><tr><td>std::vector</td><td>17ms</td><td>7ms</td><td>33ms</td><td>102ms</td><td>153ms</td></tr><tr><td>std::unordered_map</td><td>170ms</td><td>72ms</td><td>343ms</td><td>249ms</td><td>213ms</td></tr><tr><td>flat_hash_map</td><td>47ms</td><td>34ms</td><td>90ms</td><td>462ms</td><td>182ms</td></tr><tr><td>node_hash_map</td><td>152ms</td><td>68ms</td><td>182ms</td><td>236ms</td><td>183ms</td></tr></tbody></table><table><thead><tr><th>benchmarks(read)</th><th>iterate ints</th><th>find int</th><th>iterate string</th><th>find string</th></tr></thead><tbody><tr><td>std::vector</td><td>0ms</td><td>*</td><td>3ms</td><td>*</td></tr><tr><td>std::unordered_map</td><td>20ms</td><td>52ms</td><td>55ms</td><td>152ms</td></tr><tr><td>flat_hash_map</td><td>3ms</td><td>23ms</td><td>8ms</td><td>71ms</td></tr><tr><td>node_hash_map</td><td>14ms</td><td>38ms</td><td>14ms</td><td>108ms</td></tr></tbody></table><p><em>About parallel_flat_hash_map</em></p><table><thead><tr><th>inserting 1000000 ints</th><th>1-thread</th><th>8-threads</th><th>8-threads</th></tr></thead><tbody><tr><td>flat_hash_map</td><td>31ms</td><td>23ms(no lock)</td><td>214ms(mutex manually)</td></tr><tr><td>parallel_flat_hash_map</td><td>35ms</td><td>*</td><td>70ms(mutex/shared_mutex)</td></tr></tbody></table><h3 id="一个小问题"><a class="markdownIt-Anchor" href="#一个小问题"></a> 一个小问题</h3><p>在测试的时候发现，无论是 <code>flat_hash_map</code>还是 <code>node_hash_map</code>都没法插入 <code>None-moveable</code>的数据，但是 <code>std::unordered_map</code>可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br> structNonCopy &#123;<br>  <span class="hljs-built_in">NonCopy</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">NonCopy</span>(NonCopyconst&amp;) = <span class="hljs-keyword">delete</span>;<br>  NonCopy&amp;<span class="hljs-keyword">operator</span>=(NonCopyconst&amp;) = <span class="hljs-keyword">delete</span>;<br>  NonCopy&amp;<span class="hljs-keyword">operator</span>=(NonCopy&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">NonCopy</span>(NonCopy&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br>structNonMove &#123;<br>  <span class="hljs-built_in">NonMove</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">NonMove</span>(NonMoveconst&amp;) = <span class="hljs-keyword">default</span>;<br>  NonMove&amp;<span class="hljs-keyword">operator</span>=(NonMoveconst&amp;) = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">NonMove</span>(NonMove&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>  NonMove&amp;<span class="hljs-keyword">operator</span>=(NonMove&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;K, V&gt;<br><span class="hljs-keyword">using</span> fmp = flat_hash_map&lt;K, V&gt;;<br><br><span class="hljs-keyword">template</span> &lt;K, V&gt;<br><span class="hljs-keyword">using</span> nodemp = node_hash_map&lt;K, V&gt;;<br><br><span class="hljs-built_in">TEST_CASE</span>(<span class="hljs-string">&quot;hash_map&quot;</span>) &#123;<br>  fmp&lt;<span class="hljs-type">int</span>, NonCopy&gt; mp_nocp;<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, NonCopy&gt; stdmp_nocp;<br>  nodemp&lt;<span class="hljs-type">int</span>, NonCopy&gt; nodemp_nocp;<br>  fmp&lt;<span class="hljs-type">int</span>, tbs::NonMove&gt; mp_nomv;<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, NonMove&gt; stdmp_nomv;<br>  nodemp&lt;<span class="hljs-type">int</span>, NonMove&gt; nodemp_nomv;<br>  constint n = <span class="hljs-number">1e6</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    stdmp_nocp[i] =std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">NonCopy</span>());<br>    mp_nocp[i] =std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">NonCopy</span>());<br>    node_nocp[i] =std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">NonCopy</span>());<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    stdmp_nomv.<span class="hljs-built_in">emplace</span>(i, <span class="hljs-built_in">NonMove</span>());<br>  &#125;<br>  <span class="hljs-comment">// the following code can&#x27;t pass complile</span><br>  <span class="hljs-comment">// for (int i = 0; i &lt; n; i++) &#123;</span><br>  <span class="hljs-comment">//   nodemp_nomv.emplace(i, NonMove());</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// for (int i = 0; i &lt; n; i++) &#123;</span><br>  <span class="hljs-comment">//   mp_nomv.emplace(i, NonMove());</span><br>  <span class="hljs-comment">// &#125;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果说 <code>flat_hash_map</code>在 rehash的时候需要move所以禁止使用NoneMoveable还可以理解，但是 <code>node_hash_map</code>的行为应该和 <code>unordered_map</code>是一致，还是有这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>opensource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ CRTP</title>
    <link href="/C-CRTP/"/>
    <url>/C-CRTP/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原先只是了解这个名词，想着C<ins>20后静态多态直接用 <code>concept</code>来实现就好了就没细看，没必要整这些模板元编程的奇技淫巧。没想到面试某量化C</ins>开发的时候被狠狠拷打…</p></blockquote><h2 id="crtp-curiously-recurring-template-pattern"><a class="markdownIt-Anchor" href="#crtp-curiously-recurring-template-pattern"></a> CRTP (<strong>curiously recurring template pattern</strong>)</h2><p>一般认为，CRTP可以用来实现静态多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">funcImpl</span>();<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;Derived&gt; &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcImpl</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// do works here</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过CRTP可以使得类具有类似于虚函数的效果，同时又没有虚函数调用时的开销(虚函数调用需要通过虚函数指针查找虚函数表进行调用)，同时类的对象的体积相比使用虚函数也会减少(不需要存储虚函数指针)，但是缺点是无法动态绑定，感觉有点过于鸡肋。</p><p>有什么用呢？可以用来向纯虚类一样做接口：（以下类似的代码在大量数学库中出现）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ChildType&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VectorBase</span> &#123;<br>  <span class="hljs-function">ChildType &amp;<span class="hljs-title">underlying</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;ChildType &amp;&gt;(*<span class="hljs-keyword">this</span>); &#125;<br>  <span class="hljs-keyword">inline</span> ChildType &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> ChildType &amp;rhs) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">underlying</span>() = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">underlying</span>() + rhs;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">underlying</span>();<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec3f</span> : <span class="hljs-keyword">public</span> VectorBase&lt;Vec3f&gt; &#123;<br>  <span class="hljs-type">float</span> x&#123;&#125;, y&#123;&#125;, z&#123;&#125;;<br>  <span class="hljs-built_in">Vec3f</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Vec3f</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">z</span>(z) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">inline</span> Vec3f <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vec3f &amp;lhs, <span class="hljs-type">const</span> Vec3f &amp;rhs) &#123;<br>  Vec3f result;<br>  result.x = lhs.x + rhs.x;<br>  result.y = lhs.y + rhs.y;<br>  result.z = lhs.z + rhs.z;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好VectorBase后，Vec3f, Vec4f等直接实现接口就好。相比虚函数的形式，在空间和runtime都有优势。</p><h3 id="enable_shared_from_this"><a class="markdownIt-Anchor" href="#enable_shared_from_this"></a> enable_shared_from_this ?</h3><p>另一个常见的用处是与 <code>shared_ptr</code>配套的 <code>std::enable_shared_from_this</code>。若我们有一个用shared_ptr管理的资源，当我们想要接管该资源，返回一个接管 <code>this</code>的 <code>shared_ptr</code>时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// buggy</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bad</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> -&gt; shared_ptr&lt;Bad&gt; </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;Bad&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">TEST</span>() &#123;<br>  <span class="hljs-keyword">auto</span> p1 = std::<span class="hljs-built_in">make_shared</span>&lt;Bad&gt;();<br>  <span class="hljs-keyword">auto</span> p2 = p1-&gt;<span class="hljs-built_in">get</span>();<br>  <span class="hljs-built_in">assert</span>(p2.<span class="hljs-built_in">use_cont</span>() == <span class="hljs-number">1</span>);  <span class="hljs-comment">// Unexpected!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码错误的原因在于<strong>std::make_shared总是创建一个控制块</strong>，从而导致p1, p2虽然管理的对象相同，却并不知道彼此的存在。两者的 <code>ref-cnt</code>都是1，在析构的时候该对象会被析构两次。类似的bug还有 <em>effective modern c++ Item19</em> 中的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::shared_ptr&lt;Widge&gt;&gt; processedWidgets;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>    ...  <span class="hljs-comment">// process</span><br>    processedWidgets.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// buggy!</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确的做法是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>    ...  <span class="hljs-comment">// process</span><br>    processedWidgets.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">shared_from_this</span>());<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>而这里的解决方案就是CRTP。实现大概就是借用一个 <code>weak_ptr</code>，在std::shared_from_this时候利用这个weak_ptr进行新的shared_ptr的拷贝构造，从而增加引用计数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++ idioms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级高并发网络库+httpserver</title>
    <link href="/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93-httpserver/"/>
    <url>/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93-httpserver/</url>
    
    <content type="html"><![CDATA[<img src="../img/FalconLink/falcon-black.png" width="100%" height="75%"><blockquote><p>本博客部署在两个服务器上，其中一个的 HTTP 服务就是由本文介绍的 FalconLink 提供。你可以通过IP地址 121.4.49.170:20080 尝试访问。 项目地址 <a href="https://github.com/caaatch22/FalconLink">https://github.com/caaatch22/FalconLink</a></p></blockquote><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p><strong>FalconLink</strong>是一个轻量级的高并发网络库。它封装了网络编程套接字API，将其抽象成一个易用，可拓展框架。用户只需通过设置回调函数的形式注入业务逻辑。它同时也具有 HTTP 服务请求与解析的功能。</p><p><img src="../img/FalconLink/falconlink-architecture.png" alt="" /></p><p>上图是FalconLink系统架构的一个简单概括性图示。</p><ul><li>采用<strong>非阻塞socket</strong>配合<strong>边缘触发</strong>，及<em>one loop per thread</em>的主从 <code>reactor</code>设计</li><li><code>Acceptor</code> 是专门用于处理接受新用户连接请求的模块。它守候在监听端口。收到请求后建立 <code>Connection</code> 分配给 EventLoop。</li><li>FalconLink 将每个 TCP连接抽象成一个 <code>Connection</code>，一个 <code>Connection</code>对应一个连接 socket 套接字。用户可以为每一条Connection注册回调函数。</li><li>每个 <code>EventLoop</code> 都拥有一个 <code>Poller</code>。 <code>Poller</code> 负责监听已连接的套接字，将有事件触发的连接反馈给 <code>EventLoop</code>。</li><li><code>EventLoop</code>是该系统的核心组件, 每个都单独运行在一个线程中. 它从 <code>Poller</code> 中接收到有事件触发的用户连接后, 会获取并执行它们的回调函数.</li><li><code>ThreadPool</code> 线程池管理着系统中有多少个 <code>EventLoop</code> 在运行，并调度线程，防止注册过多线程导致性能下降。</li><li>支持 HTTP(GET,HEAD)请求的解析与回复，支持挂载静态 html 文件（本博客使用FalconLink的 HTTP 服务）</li><li>实现异步logger</li></ul><h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2><p>使用falconlink，可以轻易且优雅的在20行内实现一个 <code>echo server</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;falconlink.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">falconlink::InetAddr <span class="hljs-title">local_address</span><span class="hljs-params">(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">8090</span>)</span></span>;<br>  <span class="hljs-function">falconlink::Server <span class="hljs-title">echo_server</span><span class="hljs-params">(local_address)</span></span>;<br>  echo_server<br>      .<span class="hljs-built_in">onHandle</span>([&amp;](falconlink::Connection* client_conn) &#123;<br>        <span class="hljs-type">int</span> from_fd = client_conn-&gt;<span class="hljs-built_in">fd</span>();<br>        <span class="hljs-keyword">auto</span> [read, exit] = client_conn-&gt;<span class="hljs-built_in">recv</span>();<br>        <span class="hljs-keyword">if</span> (exit) &#123;<br>          client_conn-&gt;<span class="hljs-built_in">getEventLoop</span>()-&gt;<span class="hljs-built_in">deleteConnection</span>(from_fd);<br>          <span class="hljs-comment">// client_conn ptr is invalid below here, do not touch it again</span><br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只有以下四行是业务逻辑</span><br>        <span class="hljs-keyword">if</span> (read) &#123;<br>          client_conn-&gt;<span class="hljs-built_in">WriteToWriteBuffer</span>(client_conn-&gt;<span class="hljs-built_in">ReadAsString</span>());<br>          client_conn-&gt;<span class="hljs-built_in">send</span>();<br>          client_conn-&gt;<span class="hljs-built_in">clearReadBuffer</span>();<br>        &#125;<br>      <br>      &#125;)<br>      .<span class="hljs-built_in">start</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="build-test"><a class="markdownIt-Anchor" href="#build-test"></a> Build &amp; Test</h2><p>将代码 clone 到本地，进入主目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo sh ./build_support/pachages.sh<br><br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br><br>cmake ..  <span class="hljs-comment"># Debug mode by default</span><br><span class="hljs-comment"># or </span><br>cmake -DCMAKE_BUILD_TYPE=Release .. <span class="hljs-comment"># to use release mode</span><br><br>make<br><br><span class="hljs-comment"># test</span><br>make build-tests<br>make <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># or you can test each file</span><br>make xxx_test<br>./test/xxx_test<br><br></code></pre></td></tr></table></figure><h2 id="http-service"><a class="markdownIt-Anchor" href="#http-service"></a> http service</h2><p>你可以进行使用 falconlink 搭建自己的 http 服务器。<br />在 <code>build</code> 目录下 <code>make http_server</code>，然后运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">./bin/http_server [optional: port default=8090] [optional:directory <br>default=../examples/http_server/http_resource/]<br></code></pre></td></tr></table></figure><p>你可以替换自行 <code>http_resource</code>中的文件，并在浏览器中输入 <code>localhost:&#123;port&#125;</code>查看</p><h2 id="benchmark"><a class="markdownIt-Anchor" href="#benchmark"></a> Benchmark</h2><p>使用 <code>webbench</code>进行压力测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make benchmark<br></code></pre></td></tr></table></figure><ul><li><p><strong>硬件</strong>:</p><ul><li>Intel® Xeon® Gold 6148 CPU @ 2.40GHz</li><li>OS:Ubuntu 20.04 LTS,</li><li>4 核 CPU， 16GiB内存， 100GiB磁盘存储。</li></ul></li><li><p><strong>QPS</strong>: <strong>40K</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ComputerNetwork</tag>
      
      <tag>FalconLink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-project3 Query Excution</title>
    <link href="/CMU15445-project3-Query-Execution/"/>
    <url>/CMU15445-project3-Query-Execution/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><blockquote><p>在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了<a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">浏览器上的bustub</a> ，方便和我们写的对比调试。你也可以使用 <code>explain</code> 来查看他的优化策略与执行步骤。</p></blockquote><p>这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。</p><p><img src="../img/busTub/query_excution/project-structure.png" alt="" /></p><p>上图是 bustub 的整体架构。</p><h3 id="parser"><a class="markdownIt-Anchor" href="#parser"></a> Parser</h3><p>sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个<em>抽象语法树(AST, Abstract Syntax Tree)</em>。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。</p><h3 id="binder"><a class="markdownIt-Anchor" href="#binder"></a> Binder</h3><p>得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.y, table2.x <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> table1.x <span class="hljs-operator">=</span> table2.y;<br></code></pre></td></tr></table></figure><p>其中 <code>SELECT</code> 和 <code>FROM</code> 是关键字，<code>x</code> 和 <code>table1</code> 是标识符。我们可以使用 <code>explain</code> 来看看 <code>binder</code> 层（bustub-shell 未完成时也可以使用 explain）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"> === BINDER ===                                               <br> BoundSelec &#123;                                        <br>   table=BoundJoin &#123; type=Inner, left=BoundBaseTableRef &#123; table=table1, oid=25 &#125;, right=BoundBaseTableRef &#123; table=table2, oid=26 &#125;, condition=(table1.x=table2.y) &#125;, <br>   columns=[table1.y, table2.x],                       <br>   groupBy=[],<br>   having=,  <br>   where=,  <br>   limit=, <br>   offset=,<br>   order_by=[],                                 <br>   is_distinct=false,         <br>   ctes=,<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。</p><h3 id="planner"><a class="markdownIt-Anchor" href="#planner"></a> Planner</h3><p>得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。查询计划也是一棵树的形式。例如这条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.y, table2.x <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> t1.x <span class="hljs-operator">=</span> t2.y;<br></code></pre></td></tr></table></figure><p>查看 explain：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">=== PLANNER ===<br>Projection &#123; exprs=[#0.1, #0.2] &#125; | (table1.y:INTEGER, table2.x:INTEGER)                                                                                            <br>  NestedLoopJoin &#123; type=Inner, predicate=(#0.0=#1.1) &#125; | (table1.x:INTEGER, table1.y:INTEGER, table2.x:INTEGER, table2.y:INTEGER)                                   <br>    SeqScan &#123; table=table1 &#125; | (table1.x:INTEGER, table1.y:INTEGER)                                                                                                 <br>    SeqScan &#123; table=table2 &#125; | (table2.x:INTEGER, table2.y:INTEGER) <br></code></pre></td></tr></table></figure><p>上面的解释其实是树型的，如下图：<br /><img src="../img/busTub/query_excution/planner-tree.png" alt="" /><br />查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。</p><h3 id="optimizer"><a class="markdownIt-Anchor" href="#optimizer"></a> Optimizer</h3><p>生成查询计划后<br />由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化，生成优化过后的最终查询计划。Optimizer 主要有两种实现方式：</p><ul><li>Rule-based.<ul><li>通过自动重写查询来避免效率低的方法。例如我们在 Task 3 中将要实现的，将 <code>Limit + Sort</code> 合并为 <code>TopN</code>。</li><li>这种 Optimizer 不需要知道数据的具体内容，仅是根据预先定义好的规则修改 <code>Plan Node</code>。</li></ul></li><li>Cost-based.<ul><li>用某种模型来预估执行计划的时间，这就需要存很多跟数据相关的数据</li><li>通过对不同模型的 cost 比较选出执行 cost 最小的。</li><li>这也会造成一些额外开销 （运行这个cost model）</li></ul></li></ul><p>Bustub 的 Optimizer 采用第一种实现方式。</p><blockquote><p>一般来说，Planner 生成的是 Logical Plan Node，代表抽象的 Plan。Optimizer 则生成 Physical Plan Node，代表具体执行的 Plan。例如是 Join。在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。</p></blockquote><h3 id="executor"><a class="markdownIt-Anchor" href="#executor"></a> Executor</h3><p>在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了。算子也是我们在 Project 3 中需要实现的主要内容。生成算子的步骤很简单，遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor。算子的执行模型也大致分为三种：</p><ol><li><p>Iterator/Pipeline Model(volcano model)。每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。火山模型一次调用只向下层算子请求一条数据，占用内存较小，但函数调用开销大。 <img src="../img/busTub/query_excution/iterator-model.png" alt="" /></p></li><li><p>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高，但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</p></li><li><p>Vectorized/Batch Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库采用这种模型。</p></li></ol><p>Bustub 采用 Iterator Model。</p><h2 id="metadata"><a class="markdownIt-Anchor" href="#metadata"></a> Metadata</h2><p>上面介绍了 sql语句执行过程，足以让我们对整个执行引擎有大体了解。但是我在做这个 lab 时候还是有很多困惑的地方。最后是迷迷糊糊的写完了才整理了下。大体上的信息包括在下图中：<br /><img src="../img/busTub/query_excution/table-matedata.png" alt="" /><br />（图片改自<a href="https://blog.eleven.wiki/posts/cmu15-445-project3-query-execution/">这篇博客</a>）</p><h2 id="task-1-access-method-executors"><a class="markdownIt-Anchor" href="#task-1-access-method-executors"></a> Task #1 - Access Method Executors</h2><h3 id="seqscan"><a class="markdownIt-Anchor" href="#seqscan"></a> SeqScan</h3><p>实现比较简单，获取 table_iter 直接遍历即可。这里说说这个<code>plan_-&gt;filter_predicate_</code>， 他是一个<code>AbstractExpressionRef</code>，而一个<code>AbstractExpression</code>意思是一个 <em>表达式</em> ，他里面最重要的两个函数是 <code>Evaluate(const Tuple *tuple, const Schema &amp;schema)</code>和 <code>EvaluateJoin(const Tuple *left_tuple, const Schema &amp;left_schema, const Tuple *right_tuple, const Schema &amp;right_schema)</code>，主要就是用来做 filter 的。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> x <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果任何优化都没有，那么上述语句可以解析为两层：</p><ol><li>从 table1 中选出所有的 tuple。</li><li>选出 x = 1的 tuple。相当于底下的 seqscan 结点会将所有 tuple 发到上一层，然后上一层再做一次 filter。但是我们通过谓词下推，可以在seqscan 时候就通过 filter_predicate_ 将需要的过滤出来，不需要的不用发给上一层。（当然，这个例子不太准确。在这个情况下本来就是一次搞定的，总之是在复杂的时候可以把谓词下推）。<br />这个 Evaluate 返回一个 <code>Value</code>，实际上如果做filter应该返回 boolean，所以需要通过<code>filter_predicate_-&gt;Evaluate(tuple, table_info_-&gt;schema_).GetAs&lt;bool&gt;()</code>转化一下。<br />另外，seqscan 实际上不会用到 filter_predicate。后面遇到需要 predicate 的地方会再强调。</li></ol><h3 id="insert-delete"><a class="markdownIt-Anchor" href="#insert-delete"></a> Insert &amp; Delete</h3><p>这两个算子是唯二的写算子（实际上后面的优化过程中需要实现一个 update算子）。</p><p>我们先看下这两个算子的行为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">bustub<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span> (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;🥰&#x27;</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;🥰🥰&#x27;</span>, <span class="hljs-number">11</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;🥰🥰🥰&#x27;</span>, <span class="hljs-number">12</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;🥰🥰🥰🥰&#x27;</span>, <span class="hljs-number">13</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;🥰🥰🥰🥰&#x27;</span>, <span class="hljs-number">14</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> output<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> __bustub_internal.insert_rows <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5</span>                             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br></code></pre></td></tr></table></figure><p>这两个算子他们会一直 next，然后返回一次，返回的是插入/删除 tuple 的个数（所生成的tuple）。有点像 <code>pipeline breaker</code>，但是由于他们一定是顶层算子，所以好像不叫 <code>pipeline breaker</code>。</p><p>个人感觉这个返回个数的设计有点不是很合理，它一定要将个数转化成一个tuple返回。大概是这样的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*tuple =<br>    <span class="hljs-built_in">Tuple</span>(std::<span class="hljs-built_in">vector</span>&lt;Value&gt;(<span class="hljs-built_in">GetOutputSchema</span>().<span class="hljs-built_in">GetColumnCount</span>() <span class="hljs-comment">/* ColumnCount() should be one*/</span>, <span class="hljs-built_in">Value</span>(TypeId::INTEGER, counter)),<br>          &amp;<span class="hljs-built_in">GetOutputSchema</span>());<br></code></pre></td></tr></table></figure><p>另外需要注意的就是这些 增加/删除 tuple 时，对应的索引项也需要增加/删除。</p><h3 id="indexscan"><a class="markdownIt-Anchor" href="#indexscan"></a> IndexScan</h3><p>这个就简单了，在 Init() 时候保存 index_iter， next() 时直接调用再自增就可以。</p><h2 id="task-2-aggregation-join-executors"><a class="markdownIt-Anchor" href="#task-2-aggregation-join-executors"></a> Task #2 - Aggregation &amp; Join Executors</h2><h3 id="aggregation"><a class="markdownIt-Anchor" href="#aggregation"></a> Aggregation</h3><p>aggregation 操作是一个 <code>pipeline breaker</code>。他会在 init 得到全部答案然后再 next 时一条一条返回。</p><p><code>SimpleAggregationHashTable</code> 维护一张哈希表，键为 <code>AggregateKey</code>，值为 <code>AggregateValue</code>，均为 <code>std::vector&lt;Value&gt;</code>。key 代表 group by 的字段的数组，value 则是需要 aggregate 的字段的数组。在下层算子传来一个 tuple 时，将 tuple 的 group by 字段和 aggregate 字段分别提取出来，调用 <code>InsertCombine()</code> 将 group by 和 aggregate 的映射关系存入 <code>SimpleAggregationHashTable</code>。若当前 hashmap 中没有 group by 的记录，则创建初值；若已有记录，则按 aggregate 规则逐一更新所有的 aggregate 字段，例如取 max/min，求 sum 等等。例如下面这条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(t.z), <span class="hljs-built_in">max</span>(t.z), <span class="hljs-built_in">sum</span>(t.z) <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t.x, t.y;<br></code></pre></td></tr></table></figure><p>group by（AggregateKey）为 {t.x, t.y}，aggregate（AggregateValue）为 {t.z, t.z, t.z}。aggregate 规则为 {min, max, sum}。</p><p>需要额外注意 <code>count(column)</code> 和 <code>count(*)</code> 的区别，以及对空值的处理。</p><p>在 Init() 中计算出整张 hashmap 后，在 Next() 中直接利用 hashmap iterator 将结果依次取出。这里的输出形式有点奇怪，需要这样的输出：<br /><img src="../img/busTub/query_excution/aggregate-return.png" alt="" /></p><p><code>schema</code> 已经在 <code>GetOutputSchema()</code> 中准备好了。</p><h3 id="nestedloopjoin"><a class="markdownIt-Anchor" href="#nestedloopjoin"></a> NestedLoopJoin</h3><p>我的实现比较 tricky。我在 init 时候直接把下层算子（left_executor和right_executor）所有的tuple都得到了（相当于当作 pipeline breaker），保存在两张表中。再 next时候进行匹配。这里的 left-join 和 inner-join 是需要分开实现的，可以在网上查下left-join和inner-join的区别。<br />在这里判断左右两个 tuple 是否 match 就需要用到<code>plan_-&gt;Predicate().EvaluateJoin()</code>，同样要 <code>GetAs&lt;bool&gt;()</code>。</p><p>当我们得到一个 match 后，返回前记得<strong>保存上下文</strong>，例如，你可以保存 match 的 tuple 再左表中的下标和右表中的下标，这样下次调用 next 时候，就不用重新扫描一次。</p><h3 id="nestedindexjoin"><a class="markdownIt-Anchor" href="#nestedindexjoin"></a> NestedIndexJoin</h3><p>在进行 equi-join 时，如果发现 JOIN ON 右边的字段上建了 index，则 Optimizer 会将 NestedLoopJoin 优化为 NestedIndexJoin。具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p><h2 id="task-3-sort-limit-executors-and-top-n-optimization"><a class="markdownIt-Anchor" href="#task-3-sort-limit-executors-and-top-n-optimization"></a> Task #3 - Sort + Limit Executors and Top-N Optimization</h2><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h3><p>这个实验的 sort 无需进行外部排序，重载小于后就可以实现。就是比较的方式有点奇怪，可以类比以下写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">order_key.second-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;lhs, schema).<span class="hljs-built_in">CompareLessThan</span>(order_key.second-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;rhs, schema))<br></code></pre></td></tr></table></figure><h3 id="limit"><a class="markdownIt-Anchor" href="#limit"></a> limit</h3><p>简单，limit 限制在 <code>plan_-&gt;Getlimit()</code>里面。</p><h3 id="top-n-optimization-rule"><a class="markdownIt-Anchor" href="#top-n-optimization-rule"></a> Top-N Optimization Rule</h3><p>简单，优先队列重载小于（重载方式与 sort 相同），然后截取前 n 个。</p><h3 id="sort-limit-as-topn"><a class="markdownIt-Anchor" href="#sort-limit-as-topn"></a> Sort + Limit As TopN</h3><p>这是 Project 3 里最后一个必做的小问，也是唯一一个 Optimizer ，将 Sort + Limit 优化为 TopN。先看看 Optimizer 是如何执行优化规则的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Optimizer::OptimizeCustom</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;<br>  <span class="hljs-keyword">auto</span> p = plan;<br>  p = <span class="hljs-built_in">OptimizeMergeProjection</span>(p);<br>  p = <span class="hljs-built_in">OptimizeMergeFilterNLJ</span>(p);<br>  p = <span class="hljs-built_in">OptimizeNLJAsIndexJoin</span>(p);<br>  p = <span class="hljs-built_in">OptimizeNLJAsHashJoin</span>(p);  <span class="hljs-comment">// Enable this rule after you have implemented hash join.</span><br>  p = <span class="hljs-built_in">OptimizeOrderByAsIndexScan</span>(p);<br>  p = <span class="hljs-built_in">OptimizeSortLimitAsTopN</span>(p);  <span class="hljs-comment">// what we should add</span><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，让未经优化的原始 plan 树依次经历多条规则，来生成优化过的 plan。我们的任务就是新增一条规则。看看其他规则是怎么实现的，例如 NLJAsIndexJoin：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Optimizer::OptimizeNLJAsIndexJoin</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;<br>  std::vector&lt;AbstractPlanNodeRef&gt; children;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child : plan-&gt;<span class="hljs-built_in">GetChildren</span>()) &#123;<br>    children.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">OptimizeNLJAsIndexJoin</span>(child));<br>  &#125;<br>  <span class="hljs-keyword">auto</span> optimized_plan = plan-&gt;<span class="hljs-built_in">CloneWithChildren</span>(std::<span class="hljs-built_in">move</span>(children));<br><br>  <span class="hljs-keyword">if</span> (optimized_plan-&gt;<span class="hljs-built_in">GetType</span>() == PlanType::NestedLoopJoin) &#123;<br>    <span class="hljs-comment">// apply the rule and return</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> optimized_plan;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，实际上就是对 plan tree 进行后序遍历，自底向上地适用规则，改写节点。遍历到某个节点时，通过 if 语句来判断当前节点的类型是否符合我们要优化的类型，若符合则进行优化。</p><p>大致了解如何对 plan 进行优化后，就可以开始写我们的优化规则了。需要特别注意的是，能优化为一个 TopN 算子的形式是，上层节点为 Limit，下层节点为 Sort，不能反过来。同样，我们对 plan tree 进行后续遍历，在遇到 Limit 时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN。还是比较好实现的，只是代码看起来可能有点复杂。</p><h2 id="leaderboard-task"><a class="markdownIt-Anchor" href="#leaderboard-task"></a> Leaderboard Task</h2><p>暂时还没写，有空了补补</p><p><strong>AC!</strong><br /><img src="../img/busTub/query_excution/p3-result.png" alt="" /></p><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">bustub on web</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li><li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li><li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>cmu15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛中的Wavelet Tree</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84Wavelet-Tree/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84Wavelet-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="wavelet-tree-for-competitive-programming"><a class="markdownIt-Anchor" href="#wavelet-tree-for-competitive-programming"></a> Wavelet Tree for Competitive Programming</h1><blockquote><p>最近在学<em>FM-Index</em>相关算法用于数据库，了解到Wavelet Tree这一数据结构，发现其还可以应用在算法竞赛中。网上相关中文资料比较少，权当自己做个学习笔记</p></blockquote><h2 id="开始之前"><a class="markdownIt-Anchor" href="#开始之前"></a> 开始之前</h2><p>在学习<code>wavelet tree</code>前，不妨看看他能解决什么样的问题。</p><p>假设我们有一长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0...</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0...n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。在算法竞赛中，典型的数据量是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>9</mn></mrow><annotation encoding="application/x-tex">n = 1e5,  |A[i]| &lt;= 1e9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span></span></span></span></p><ul><li>区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 中元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的<code>出现次数</code></li><li>区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 中的<code>第k小数</code></li><li>区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 上 <code>小于等于x的数的个数</code></li><li>…</li></ul><p>以上问题都可以通过<em>可持久化线段树</em>在解决。那为什么还需要wavelet tree呢，我们都知道可持久化线段树的常数很大，并且十分消耗空间，在有些苛刻的题目下可能会被卡  <s>好吧应该都是金牌题，不是我该考虑的</s> 。利用wavelet tree可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(\sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span>时间内完成的同时（且优秀的常数），若使用<code>bitvector</code>优化空间，空间上大概比可持久化线段树少一个量级。最重要的一点是，我个人觉得他比主席树更加直观易懂。<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> = | <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{1, 2, \cdots, \sigma\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">}</span></span></span></span>| （用于序列上时是值域大小）。</p><blockquote><p>用wavelet tree的缺点就是带修改操作比较难写，码量较大，一般不会在比赛时使用。</p></blockquote><h2 id="wavelet-tree"><a class="markdownIt-Anchor" href="#wavelet-tree"></a> Wavelet Tree</h2><p><img src="../img/waveletTree/waveletTree.png" alt="" /></p><p>该图给出了用序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><mn>7</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A = [7, 3, 5, 6, 1, 3, 2, 7, 8, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 构建的wavelet tree的形态。对于树上的每个节点，我们会将其按照值域分成两个部分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[low, mid), [mid, high)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>。通过 <strong>稳定划分</strong>（stable_partition，即不改变相对顺序的情况下划分）将该节点上的序列中小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>的划分到左子树中，大于等于mid的划分到右子树中，递归直至节点中只有一种值时为叶节点。需要注意的是，我们并不会在叶子节点中直接存储序列的值，而是通过某个方法使得我们能够使用较小的空间的情况下得到足够的信息。</p><p>设根节点编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">u = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，其左子树的根节点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">2 * u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> , 右子树的根节点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>u</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 * u + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，以此类推。每个节点都对应一对左闭右开的区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[lo, hi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>，表示该节点中数值的值域范围。同时有一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mo>+</mo><mi>h</mi><mi>i</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">mid = \lfloor \frac{lo + hi}{2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span> ，表示该节点左右子树分裂标准，即左子树中值域范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[lo, mid)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> , 右子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[mid, hi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 。</p><p>在wavelet tree中，我们实际上在维护一个二维数组<code>vector&lt;vector&lt;int&gt;&gt; c</code>，我们不妨叫他<strong>前缀计数数组</strong>，其中 <strong><code>c[u][i]</code>表示的是u结点中下标为[0, i)中的数有多少个小于该节点对应的mid</strong>。另外，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>结点中有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个数，那么<code>c[u].size() = n + 1</code>， 我们另<code>c[u][0] = 0</code>。例如，下图给出了部分结点对应的 <code>c[u][i]</code>数组<br /><img src="../img/waveletTree/Counting-array.png" alt="" /></p><p>现在，我们来看如何用这个构建好的前缀计数数组完成以下的查询问题：</p><h3 id="rankint-val-int-pos"><a class="markdownIt-Anchor" href="#rankint-val-int-pos"></a> rank(int val, int pos)</h3><p>该函数返回区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 中值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的数的个数（我也不知道为什么叫rank。。。或许这个名称是由bitvector中继承而来？）。有了这个函数，我们就容易得到区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 内某个数的出现次数，就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank(val, j) - rank(val, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></p><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_u (val, pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 为结点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>中值为val的数在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 中的出现次数（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>&lt;</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pos &lt;= size(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span> ）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>为节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>分裂标准，我们可以得到：</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>&lt;</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">val &lt; mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mrow><mi>L</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_u(val, pos) = rank_{LeftChild(u)}(val, c[u][pos])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>&gt;</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">val &gt;= mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>,  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mrow><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_u(val, pos) = rank_{RightChild(u)}(val, pos - c[u][pos])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li></ul><p>如何理解上述变化呢，其实也很简单，就是要理解<code>c[u][i]</code>的意义，它同时也表示将u结点中下标为i的点映射到子结点中后他的位置。而映射规则为<strong>若这个数小于mid，则将其映射到左儿子的c[u][i]处；若这个数大于等于mid，则将其映射到右儿子的i-c[u][i]处</strong> 不理解的可再仔细想想<code>c[u][i]</code>的这两个解释之间的等价性。</p><p>有了上述说明，我们就容易递归的完成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">rank</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>操作。例如，假设我们需要得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>=</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_1(val = 3, pos = 7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span><br />-由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>&lt;</mo><mi>m</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">，</mi><mi>c</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>7</mn><mo stretchy="false">]</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3&lt;mid，c[1][7] = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">7</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>, 则递归左子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_2(3, 4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span>；</p><ul><li>左子树中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>4</mn><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 &gt;= (mid = 2), 4-c[2][4] = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，递归到右子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mn>5</mn></msub><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_5(3, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></li><li>右子树中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>3</mn><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3 &gt;= (mid = 3), 3-c[5][3] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，递归到右子树</li><li>右子树为叶子节点，则此时结点内的树的个数（即为上一步中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3-c[5][3] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>）为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的个数</li></ul><h3 id="quantileint-k-int-l-int-r"><a class="markdownIt-Anchor" href="#quantileint-k-int-l-int-r"></a> quantile(int k, int l, int r)</h3><p>该函数返回区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>间的第k小数（最小的为第一小）。我们知道，<code>c[u][l]</code>表示下标为结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>中有多少个下标在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0， l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>中的数被映射到了左子树。那么，</p><ul><li>若<code>c[u][r] - c[u][l] &gt;= k</code>，则区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>内第k小即为左子树中的第k小。</li><li>若<code>c[u][r] - c[u][l] &lt; k</code>，则区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>内第k小即为右子树中的第<code>k - (c[u][r] - c[u][l])</code>小。</li></ul><p>从而我们可以递归的进行求解。</p><h3 id="c数组的构建"><a class="markdownIt-Anchor" href="#c数组的构建"></a> c数组的构建</h3><p>实际上上面已经讲的差不多了，直接看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 参数都是该结点对应序列相关</span><br><span class="hljs-comment">// u: 该结点编号</span><br><span class="hljs-comment">// begin， end: 该结点对应序列的首个，末尾迭代器</span><br><span class="hljs-comment">// lo, hi： 该结点对应值域为 [lo, hi)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(iter begin, iter end, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(hi - lo == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>    c[u].<span class="hljs-built_in">reserve</span>(end - begin + <span class="hljs-number">1</span>); <span class="hljs-comment">// reverse只分配空间不进行构造，所以后面还可以push_back</span><br>    c[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin; it != end; ++it) &#123;<br>        c[u].<span class="hljs-built_in">push_back</span>(c[u].<span class="hljs-built_in">back</span>() + (*it &lt; m));<br>    &#125;<br><br>    <span class="hljs-comment">// 稳定划分，将[begin, end)间的小于m的值划分到前半部分，pivot为后半部分首个迭代器</span><br>    <span class="hljs-keyword">auto</span> pivot = <span class="hljs-built_in">stable_partition</span>(begin, end, [=](<span class="hljs-type">int</span> i)&#123;<span class="hljs-keyword">return</span> i &lt; m&#125;;);<br><br>    <span class="hljs-built_in">build</span>(begin, pivot, lo, m, <span class="hljs-number">2</span> * u);<br>    <span class="hljs-built_in">build</span>(pivot, end, m, hi, <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>到这个，我们已经可以利用没有进行空间优化的wavelet tree轻松切掉这道 <a href="https://www.luogu.com.cn/problem/P3834">可持久化线段树的模板题</a>了，代码如下</p><h2 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaveletTree</span> &#123;<br>    <span class="hljs-keyword">using</span> iter = vector&lt;<span class="hljs-type">int</span>&gt;::iterator;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; c;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> SIGMA;<br><br>    <span class="hljs-built_in">WaveletTree</span>(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> sigma): <span class="hljs-built_in">c</span>(sigma*<span class="hljs-number">2</span>), <span class="hljs-built_in">SIGMA</span>(sigma) &#123;<br>        <span class="hljs-built_in">build</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, SIGMA, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(iter begin, iter end, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(hi - lo == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>        c[u].<span class="hljs-built_in">reserve</span>(end - begin + <span class="hljs-number">1</span>);<br>        c[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin; it != end; ++it) &#123;<br>            c[u].<span class="hljs-built_in">push_back</span>(c[u].<span class="hljs-built_in">back</span>() + (*it &lt; m));<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">stable_partition</span>(begin, end, [=](<span class="hljs-type">int</span> i)<br>                                  &#123; <span class="hljs-keyword">return</span> i &lt; m; &#125;);<br>        <span class="hljs-built_in">build</span>(begin, p, lo, m, <span class="hljs-number">2</span> * u);<br>        <span class="hljs-built_in">build</span>(p, end, m, hi, <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// occurrences of val in position[0, i)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(val &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> val &gt;= SIGMA) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>, hi = SIGMA, u = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hi - lo &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(val &lt; m) &#123;<br>                i = c[u][i], hi = m;<br>                u = u * <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i -= c[u][i], lo = m;<br>                u = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-comment">// get kth smallest number in [l, r)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quantile</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// assert(k &gt; 0 &amp;&amp; k &lt;= j - i);</span><br>        <span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>, hi = SIGMA, u = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hi - lo &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> nl = c[u][l], nr = c[u][r];<br>            <span class="hljs-keyword">if</span>(k &lt;= nr - nl) &#123;<br>                r = nr, l = nl, hi = m;<br>                u = <span class="hljs-number">2</span> * u;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= nr - nl;<br>                r -= nr, l -= nl, lo = m;<br>                u = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lo;   <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">int</span> n, q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;x : a) &#123;<br>        cin &gt;&gt; x;<br>    &#125;<br>    <span class="hljs-function">WaveletTree <span class="hljs-title">wt</span><span class="hljs-params">(a, *max_element(a.begin(), a.end()) + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">while</span>(q --) &#123;<br>        <span class="hljs-type">int</span> k, l, r;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;<br>        l--;<br>        cout &lt;&lt; wt.<span class="hljs-built_in">quantile</span>(k, l, r) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>icpc</tag>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-project2 Concurrent B+ tree</title>
    <link href="/CMU15445-project2-Concurrent-B-tree/"/>
    <url>/CMU15445-project2-Concurrent-B-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><blockquote><p>这个实验应该是最难的一个实验了。。。（感觉和Project 4 —— Transaction实现的难度差不多） 另外，2022fall版本的B+ tree更是变态，因为几乎没有给任何内部的API，让人无从下手。建议到 Github repo 里找到20年的，我基本是根据里面定义的函数来实现的。</p></blockquote><p>实验材料<s>贴心的</s>为你分成了两个检查点，四个小任务。</p><p>Checkpoint #1</p><ul><li>Task #1 - B+Tree Pages</li><li>Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</li></ul><p>Checkpoint #2</p><ul><li>Task #3 - Index Iterator</li><li>Task #4 - Concurrent Index</li></ul><h2 id="task-1-btree-pages"><a class="markdownIt-Anchor" href="#task-1-btree-pages"></a> Task #1 - B+Tree Pages</h2><p>第一个任务算是热身，主要是搞清楚 B+ 树的一些类之间的关系。<br />我们知道，数据库中的索引也是数据，同样以 page 的形式被组织。我们先来看看要完成的这些类之间的关系。</p><p><img src="../img/busTub/B-tree/B-tree-page-relation.png" alt="" /></p><p><code>B+ tree internal page</code> 与 <code>B + tree leaf page</code> 都继承自<code>B + tree page</code>，<code>B + tree page</code> 中定义了 B+ 树每个结点的一些信息。而B + Tree 这个类则是Checkpoint 1的主要对象，它对<code>internal page</code> 以及 <code>leaf page</code> 进行管理，并对外开放接口。而在内存中，internal page 与 leaf page 都属于 page 的一部分，关系如下图所示。他们就是 <code>page</code> 中的 data 部分。因此，每次<br />从 buffer pool manager 得到一个 page 后，若是将他们用作 B+树的结点，则需要对这个 data 进行<strong>释义</strong>，也就是将他强制转化为internal page 或者 leaf page。这在 C++ 中通过 <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast"><strong>reinterpret_cast</strong></a> 完成。</p><p><img src="../img/busTub/B-tree/pages.png" alt="" /></p><p>然后就是一些getter，setter的实现。这个 <code>MappingType array[1]</code> 是个奇技淫巧叫<a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>，由于整个internal page的大小是确定的（由data[buffer_size]转义而来），这个 array 的大小就是去掉 header后的大小。（另外，实际上应该写作 <code>MappingType array[0]</code>，不然过不了 check-format）。</p><h2 id="task-2-btree-data-structure-insertion-deletion-point-search"><a class="markdownIt-Anchor" href="#task-2-btree-data-structure-insertion-deletion-point-search"></a> Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</h2><p>这个任务就是本实验最为核心的一点——实现基于磁盘的 B+ 树数据结构。这里不会详细展开，因为过于复杂且很多细节<s>因为忘光了</s>。给个<a href="https://github.com/cmu-db/bustub/blob/1cc1bb2f7b0746c67a974c0554c843ac35519315/src/storage/index/b_plus_tree.cpp">20年fall</a>的B+ tree，功能是一样的，但是提供了完善的内部接口，照着这个和书上完成要清晰不少。</p><h3 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> debug</h3><p>TAs准备了b_plus_tree_printer工具，并且已经准备的Draw/ToString方法，善用它们将B+树可视化，更好的观察插入、删除行为是否正确。 示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;     <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> key : keys) &#123;       <br>  <span class="hljs-type">int64_t</span> value = key &amp; <span class="hljs-number">0xFFFFFFFF</span>;       <br>  rid.<span class="hljs-built_in">Set</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(key &gt;&gt; <span class="hljs-number">32</span>), value);       <br>  index_key.<span class="hljs-built_in">SetFromInteger</span>(key);       <br>  tree.<span class="hljs-built_in">Insert</span>(index_key, rid, transaction);       <br>  tree.<span class="hljs-built_in">Draw</span>(bpm, <span class="hljs-string">&quot;xxxxx/InsertTest_step&quot;</span> + std::<span class="hljs-built_in">to_string</span>(step++) + <span class="hljs-string">&quot;_insert&quot;</span> + std::<span class="hljs-built_in">to_string</span>(key) + <span class="hljs-string">&quot;.dot&quot;</span>);     <br>&#125;     <br>tree.<span class="hljs-built_in">Draw</span>(bpm, <span class="hljs-string">&quot;xxxxxx/InsertTest_step.dot&quot;</span>);<br></code></pre></td></tr></table></figure><p>得到生成的文件后打开，可以和<a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">reference solution</a>比较。</p><h2 id="task-3-index-iterator"><a class="markdownIt-Anchor" href="#task-3-index-iterator"></a> Task #3 - Index Iterator</h2><p>我想重点说下这个 iterator 的实现，因为在这个实验中，我调了最久的 bug 就出现在这个子任务中。（实际上已经过了lab-2的评测已经过了，是在 lab3评测时发生锁资源的问题）</p><p>记得哪个大佬说过，如何看一个人的 C++ 水平，从他写的构造函数就可以略窥一二。C++ 的构造函数属实花里胡哨，<code>copy ctor</code>, <code>copy assignment</code>, <code>move ctor</code>, <code>move assignment</code> , 再加上 <code>initializatier list</code>以及模板… 哪些要写，哪些应当禁止都是门学问。</p><p>根据 <a href="https://zh.wikipedia.org/zh-hans/RAII">RAII</a> 的思想，C++ 的 contructor（配合dtor）肩负了管理资源的作用。这个资源不知包括内存资源，还包括锁资源等等。而对于 Index iterator 来说，每个 iterator 都带有一个隐含的读属性，并发读要求对 page 上读锁，但是我们的 iterator 又不直接管理 page 资源，需要通过传入指针（用shared_ptr最好）的方式对 page 进行操作。</p><p>我们来看这个例子 在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">index_iter_ = <span class="hljs-built_in">GetBPlusTreeIndex</span>()-&gt;<span class="hljs-built_in">GetBeginIterator</span>();<br></code></pre></td></tr></table></figure><p>这是lab3中用到索引迭代器的一个地方的代码。注意到这会产生一个临时对象，并把它赋值给 index_iter_。如果我们在析构的时候释放了对应 page 的锁而没有写<code>copy assignment</code>，编译器生成的assignment是不会在赋值的时候为page上锁的。</p><p>这个bug归根结底在于，我们的迭代器应该是 <strong>值语义(value semantic)</strong> 的（至少对于锁资源来讲）</p><p>我们用 <strong>copy and swap</strong> idiom 来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-title">INDEXITERATOR_TYPE::IndexIterator</span><span class="hljs-params">(BufferPoolManager *bpm, Page *page, <span class="hljs-type">int</span> index, <span class="hljs-type">page_id_t</span> page_id)</span></span><br><span class="hljs-function">    : bpm_(bpm), page_(page), index_(index), page_id_(page_id) &#123;</span><br>  <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>    leaf_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(page-&gt;<span class="hljs-built_in">GetData</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    leaf_ = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-title">INDEXITERATOR_TYPE::IndexIterator</span><span class="hljs-params">(<span class="hljs-type">const</span> IndexIterator &amp;rhs)</span></span><br><span class="hljs-function">    : bpm_(rhs.bpm_), index_(rhs.index_), page_id_(rhs.page_id_), leaf_(rhs.leaf_) &#123;</span><br>  <span class="hljs-keyword">if</span> (page_id_ != INVALID_PAGE_ID) &#123;<br>    page_ = bpm_-&gt;<span class="hljs-built_in">FetchPage</span>(page_id_);<br>    page_-&gt;<span class="hljs-built_in">RLatch</span>();<br>  &#125;<br>&#125;<br><br>INDEX_TEMPLATE_ARGUMENTS<br><span class="hljs-keyword">auto</span> INDEXITERATOR_TYPE::<span class="hljs-keyword">operator</span>=(IndexIterator rhs) -&gt; IndexIterator &amp; &#123;<br>  <span class="hljs-built_in">Swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(IndexIterator &amp;lhs, IndexIterator &amp;rhs)</span> </span>&#123;<br>  <span class="hljs-keyword">using</span> std::swap;<br>  <span class="hljs-built_in">swap</span>(lhs.bpm_, rhs.bpm_);<br>  <span class="hljs-built_in">swap</span>(lhs.page_, rhs.page_);<br>  <span class="hljs-built_in">swap</span>(lhs.index_, rhs.index_);<br>  <span class="hljs-built_in">swap</span>(lhs.page_id_, rhs.page_id_);<br>  <span class="hljs-built_in">swap</span>(lhs.leaf_, rhs.leaf_);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="task-4-index-iterator"><a class="markdownIt-Anchor" href="#task-4-index-iterator"></a> Task #4 - Index Iterator</h2><p>这是并发 B+ 树的重点。我们要使此前实现的 B+ 树支持并发的 Search/Insert/Delete 操作。整棵树一把锁逻辑上来说当然是可以的，但性能肯定不行，我们需要更加细粒度的锁管理。在这里，我们会使用一种特殊的加锁方式，叫做 latch crabbing。顾名思义，就像螃蟹一样，移动一只脚，放下，移动另一只脚，再放下。基本思想是：</p><ol><li>先锁住 parent page，</li><li>再锁住 child page，</li><li>假设 child page 是安全的，则释放 parent page 的锁。安全指当前 page 在当前操作下一定不会发生 split/steal/merge。同时，安全对不同操作的定义是不同的，Search 时，任何节点都安全；Insert 时，判断 max size；Delete 时，判断 min size。</li></ol><p>这么做的原因和正确性还是比较明显的。当 page 为安全的时候，当前操作仅可能改变此 page 及其 child page 的值，因此可以提前释放掉其祖先的锁来提高并发性能。</p><p>最后是AC截图：</p><p><img src="../img/busTub/B-tree/p2-result.png" alt="" /></p><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li><li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li><li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>cmu15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-project1 Buffer Pool Manager</title>
    <link href="/CMU15445-project1-Buffer-Pool-Manager/"/>
    <url>/CMU15445-project1-Buffer-Pool-Manager/</url>
    
    <content type="html"><![CDATA[<h1 id="buffer-pool-manager"><a class="markdownIt-Anchor" href="#buffer-pool-manager"></a> Buffer Pool Manager</h1><blockquote><p>cmu15445 是一门关于数据库管理系统（DBMS）设计与实现的经典公开课，是很多dba和内核开发人员的入门课程。开课教授Andy Pavlo 非常风趣幽默，他有自己上课的DJ，他曾在浴缸里录课，且时常语出惊人。这门课的实验项目BusTub非常有挑战性，并对所有人开放评测资源。</p></blockquote><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>BusTub是一个面向磁盘的 DBMS(Database Management System)。由于磁盘上的数据不支持字节粒度的访问，这就需要一个管理页的中间层，而 Andy 坚持<a href="https://db.cs.cmu.edu/mmap-cidr2022/">&quot;The OS is not your friend&quot;</a>， 反对使用 mmap 进行页操作，因此实验一的目标便在于通过实现 Buffer Pool Manager 主动管理磁盘中的页（page）在内存中的缓存，从而，最小化磁盘访问次数（时间上）、最大化相关数据连续（空间上）。</p><p>这次实验有三个子任务，分别是</p><ul><li>Task #1: Extendible Hash Table</li><li>Task #2: LRU-K Replacer</li><li>Task #3: Buffer Pool Manager Instance</li></ul><p>可拓展哈希表是这个是实验中相对独立的模块。这里不会讲它的细节，后面的两个任务中需要用到哈希表的地方我直接用std::unordered_map替代，而且效率还更高。应该是因为 Extendible Hash Table 要求线程安全，为了方便在我在每个函数入口都加了大锁。<br />想要 Extendible Hash Table 具体细节的可以看这个<a href="https://www.bilibili.com/video/BV1nV4y1N7LM/?spm_id_from=333.788&amp;vd_source=11c680307875dda5d5b5c13fca2e5c57">b站视频</a>。关于它的优化，我想可以进行更细粒度的锁管理甚至写一个无锁(lockfree)的哈希表。</p><h2 id="buffer-pool-manager-2"><a class="markdownIt-Anchor" href="#buffer-pool-manager-2"></a> Buffer Pool Manager</h2><p>在后两个实验开始之前，我建议先将Task #2和Task #3的<a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">实验材料</a>完整的看完在开始写代码。因为 <code>replacer</code> 和 <code>buffer pool manager</code> 有较大程度的耦合。很多API设计需要对照两个组件才能知道自己应该维护的数据与功能的边界。为了更符合直觉，我会先阐述 <code>buffer pool manager</code> 的设计，同时会穿插着 <code>LRU-k</code> 的API什么时候，在哪用。</p><p><strong>Buffer Pool Manager</strong> 维护的数据的基本单位为一段逻辑连续的字节数组，在磁盘上表现为<strong>页（page）</strong>，页内部结构有自己的一些结构（包括header, content等），在这个实验中我们只关心 <code>page_id_</code> (页的唯一标识)， <code>pin_conut_</code> 以及 <code>is_dirty_</code> 。对应在内存上，我们用 <strong>frame</strong> 这个词代表 <strong>框</strong>，就是装着某个物理页的框。在代码中其实就是buffer pool管理着一大片内存 <code>Page pages[pool_size_]</code>，但是 buffer pool 初始化时（资源获取时）我们得到的 pages 并不包含我们想要的页，它里面的数据是没有意义的，从而它是一个<em>空的框</em>。frame_id指的就是这个数组的下标。里面装的页有自己的<code>page_id</code>。另外，我们用一个哈希表<code>page_table_</code>保存从 页号(page id) 到 框号(frame_id) 的映射。</p><img src="../img/busTub/buffer_pool_manager/pages.png" width="75%" height="75%"><p>管理帧的内存池大小一般来说是远小于磁盘的，因此在内存池满了后，再从磁盘加载新的页到内存池，需要某种替换策略（replacer）将一些不再使用的页踢出内存池以腾出空间。</p><p>buffer pool manager 的<strong>实现核心</strong>在于对所有 page 的状态的管理。每个page有四种状态：</p><ol><li><strong>Not Allocated(Not Exist):</strong> 我们将不存在的 page 也当作一种状态</li><li><strong>Allocated but Not in MEM:</strong> allocated 但是不存在于内存中（某一时刻内存装的 page 达到上线后被 evict 出内存）</li><li><strong>Unpinned and in MEM:</strong> 随时可能被 evict</li><li><strong>Pinned(definitely in MEM)</strong></li></ol><p><strong>这几种状态是互斥的</strong></p><p>待实现函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> -&gt; Page *</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> -&gt; Page *</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">bool</span> is_dirty)</span> -&gt; <span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::DeletePgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> -&gt; <span class="hljs-type">bool</span></span><br></code></pre></td></tr></table></figure><p>便是驱动状态机中上述状态发生改变的动作（action），（注意： <em>AllocatePage 和 DeallocatePage</em>不对外部公开） 状态机如下：</p><img src="../img/busTub/buffer_pool_manager/state-machine-of-page.png" width="50%" height="50%"><p>每个函数声明处的注释已经非常详细的描述了函数行为了。以下列出一些我在做的时候容易困惑的点：</p><ul><li><code>page_table_</code>维护的只是在内存中的page的<code>page_id</code>到<code>frame_id</code>的映射。也就是说它不保存 <em>Allocated but not in MEM</em> 的 page（因为在磁盘上的page也没有一个到 <code>frame_id</code> 的映射）</li><li><code>Unpin</code> 操作并不一定会使 page 变成 <em>Unpinned and in MEM</em>，因为这只是这一个 <em>worker（一般来说是一个thread）</em> 对该 page 进行 unpin，其他线程可能也正在读取这个 page 的内容。 只有当 某次 Unpin 操作后，它的<code>pin_count_</code> 等于0时，才能让这个 page 变成 <code>evitable</code>的状态（在 replacer 中维护）</li><li><code>AllocatePage</code> 只在 <code>NewPage</code>中用到，<code>DeallocatePage</code> 只在 <code>DeletePage</code> 中用到</li><li><code>Unpin</code> 的 <code>is_dirty</code> 参数为 true 时，将这个 page 的<code>is_dirty_</code>设置为true， <strong>而当参数为false时，不可以将page的 is_dirty_ 设置为false! 而应该保持原 dirty 状态不变</strong> 因为 <code>is_dirty</code> 参数表示的只是这个线程是否对这个 page 有修改操作。（这个点害我debug了好久）</li></ul><p>现在我们借助 replacer 的 API 来理解一下每个 page 在他的生命周期中需要被维护什么内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发生在NewPage和FetchPage时，且free_list_为空</span><br><span class="hljs-comment"> * @param[out] frame_id id of frame that is evicted.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Evict</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> *frame_id)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br><span class="hljs-comment">/* 发生在NewPage和FetchPage中 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecordAccess</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span></span>;<br><br><span class="hljs-comment">/** 在NewPage和FetchPage set_evictable 设置为 false</span><br><span class="hljs-comment"> *  在 Unpin后，pin_count为0下 set_evictable 设置为 true</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEvictable</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id, <span class="hljs-type">bool</span> set_evictable)</span></span>;<br><br><span class="hljs-comment">/* 发生在DeletePage中 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span></span>;<br></code></pre></td></tr></table></figure><p>以 FetchPageImpl 为例强调下一些实现的细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> -&gt; Page * </span>&#123;<br>  <span class="hljs-comment">// 1. 上锁！</span><br>  <span class="hljs-comment">// 2. 查看 page 是否在 page_table_ 中</span><br>  <span class="hljs-comment">//  2.1 若在 </span><br>  <span class="hljs-comment">//   2.1.2 得到frame_id, 目标为pages[frame_id]</span><br>  <span class="hljs-comment">//   2.1.3 目标内部的pin_count状态维护</span><br>  <span class="hljs-comment">//   2.1.4 replacer 维护recordAccess和setEvictable</span><br>  <span class="hljs-comment">//   2.1.5 返回</span><br>  <span class="hljs-comment">// 2.2 若不在</span><br>  <span class="hljs-comment">//  2.2.1 找一个可用的 frame (先从free list里找，没有则让 replacer evict一个)</span><br>  <span class="hljs-comment">//  2.2.2 清空frame_id中原来的信息 （包括old_page dirty的话写回磁盘）</span><br>  <span class="hljs-comment">//  2.2.3 维护 page_table (删除这个frame_id对应的old_page的信息)</span><br>  <span class="hljs-comment">//  2.2.4 设置新的page_id，从磁盘中读入，并维护新 page 内部信息</span><br>  <span class="hljs-comment">//  2.2.5 维护 replacer 相关</span><br>  <span class="hljs-comment">//  2.2.6 维护page_table </span><br>  <span class="hljs-comment">//  2.2.7 返回</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lru-k-replacer"><a class="markdownIt-Anchor" href="#lru-k-replacer"></a> LRU-K Replacer</h2><p><strong>LRU-k evict policy</strong> 是让访问次数未到 k 的结点会被优先 evict 出去（这么做或许是为了防止一些微小的 <em>扰动访问</em> 污染了原来经常访问的区域），然后对于访问次数到达 k 次的结点则按照最近访问时间（或逻辑上的时间戳）最久远的被 evict。（实际上按照原始论文和 slides 上的意思应该是最近访问时间和第前 k 次访问时间<strong>之差</strong>相差最大的被 evict，但是按照前面的方法也过了。。。）</p><ul><li><a href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf">LRU-k的原始论文</a></li><li><a href="https://leetcode.cn/problems/lru-cache/">leetcode上的lru算法</a>，不熟悉的可以先试试</li></ul><p>针对 LRU-k 算法，我实现了两种方法，简单说一下思路。</p><h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h3><p>维护两个链表，一个存未到 k 次访问的<code>frame_id</code>,另一个存已到（或超过）k 次访问的 <code>frame_id</code>，我们分别将其叫做 <code>history_list</code>以及<code>cache_list</code>。</p><p>同时维护一个从<code>frame_id</code>到 <code>FrameEntry</code>的哈希表，这个<code>FrameEntry</code>保存了<code>hit_count</code>，<code>evictible</code>以及一个list&lt;frame_id_t&gt;的迭代器。</p><ul><li><strong>Evict:</strong> 若 hist_list 非空，找到第一个 evictable 的 frame 将其踢出，否则找cache_list 中第一个evictable 的 frame。</li><li><strong>RecordAccess(frame_id):</strong>  通过 <code>FrameEntry</code> 查看 hit_count （1）若他是第一次访问，则将其放在 history_list 尾部，注意，同时还要维护这个 frame_id 在FrameEntry 中的迭代器 。（2）若 new_count == k 则在history_list中删去这个frame(无需遍历，通过保存在哈希表中的迭代器进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 删除)，添加到 cache_list 中，同时维护哈希表 （3）new_count &gt; k，将这个 frame_id 移动到 cache_list 最后（删除和添加都可以做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ）</li><li><strong>SetEvictable</strong> 和 <strong>Remove</strong>都可以类似的操作。</li></ul><h3 id="方法一时间复杂度"><a class="markdownIt-Anchor" href="#方法一时间复杂度"></a> 方法一时间复杂度：</h3><p>假设 history_list 和 cache_list 中的元素个数都是 n， 两个队列中 non-evictable 的个数都为 m，则 Evict 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>（最差遍历 m 个元素） 其余操作时间复杂度都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。需要注意的是，RecordAccess 要比 Evict 经常使用的多，且 Evict 遍历 m 个元素是在 non-evictable page 都在 evictable page 的先前访问。实际上可以看作一个常数。</p><h3 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h3><p>为了绝对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的 evict，我们可以使用std::set（红黑树），结点内部维护 <em>hit_count</em> 和 <em>到达时间</em>，需要重载&lt;=，就可以达到。但是这种做法不仅常数大（结点之间比较需要先比较访问了k次没有，对到达k次和没到达k次的结点还需分别比较），更致命的是它使得 <code>RecordAccess(frame_id)</code>的复杂度变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> （需要一次 find， 一次 delete，一次 insert）。</p><h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2><p>这是四个实验（不算primer）中最简单的一个了，如果实在卡在某部分的话试试通过分析测试样例来得到预期行为，或者使用 gdb （可以使用 lldb 配合 vscode 代替命令行条件下进行调试）。相信我，越早学会如何调试对后面越有益。</p><p>最后当然是 AC 截图了</p><p><img src="../img/busTub/buffer_pool_manager/p1-result.png" alt="" /></p><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li><li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li><li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>cmu15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs144-note1</title>
    <link href="/cs144-note1/"/>
    <url>/cs144-note1/</url>
    
    <content type="html"><![CDATA[<h1 id="computer-network"><a class="markdownIt-Anchor" href="#computer-network"></a> Computer Network</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> introduction</h2><p>dominant model : bidirectional, reliable byte stream connection</p><ul><li><p><strong>http</strong>: hypertext transfer protocol : designed to be a document centric way for programs to communicate.<br />Client  —&gt;  Server  model</p></li><li><p><strong>Bit-Torrent</strong>: (peer-to-peer model) a client requests document from other clients, a single client can request from many others.<br />these collections of collaborating clients are called <strong>swarms</strong><br />when a client wants to downloads a file, it first find <code>torrent</code>, usually using www and download using http.<br /><strong>torrent</strong> file describes information about data file, also tells bit-torrent about the <strong>tracker</strong> (a node keeps track names of clients of the swarm)</p></li><li><p><strong>skype</strong>: client &lt;–NAT–&gt;client   two clients request data from each other</p><p><em>NAT</em> : network address translator<br />if you’re <em>behind a NAT</em>, you can open connections out to the internet, but other nodes on the internet can’t easily open connections to you.</p></li></ul><h2 id="the-4-layer-internet-model"><a class="markdownIt-Anchor" href="#the-4-layer-internet-model"></a> The 4 layer Internet Model</h2><h3 id="network-layer-and-link-layer"><a class="markdownIt-Anchor" href="#network-layer-and-link-layer"></a> Network layer and link layer</h3><img src = "../img/cs144/4LayerModel.png" align="left" width="300px" height="430"/><span style="float:left"></span> The Internet is made up of `event hosts`, `links` and `routers`. <p>data is delivered in <strong>packets</strong><br />a packet is a self-contained unit consisting of the data we want to be delivered.</p><p>link layer’s job is  to carry the data over one link  at a time.<br /><code>ethernet</code> and <code>wifi</code> --&gt; two examples of different links layers</p><p>Network layer’s job is to deliver packets end to end across the internet.<br /><strong>a packet is a collection data with header</strong>.<br /><img src = "../img/cs144/packet.png" align="right" width="380" height ="100px"/></p><p>network layer packet are called <code>datagram</code>.</p><p><img src="../img/cs144%5CNetwork_link.png" alt="" /></p><h3 id="the-network-layer-is-special"><a class="markdownIt-Anchor" href="#the-network-layer-is-special"></a> The network layer  is “special”</h3><p>we must use the internet Protocol (IP)</p><ul><li>IP makes a best-effort attempt to deliver our datagrams to the other end. <strong>But it make no promise</strong></li><li>IP datagrams can get lost, delivered out of order, and be corrupted. <strong>No guarantees</strong>.</li></ul><h3 id="transport-layer"><a class="markdownIt-Anchor" href="#transport-layer"></a> Transport layer</h3><p>the most common transport layer is <strong>TCP</strong> (transmission control protocol)</p><ul><li>guarantee correct in-order delivery of data</li></ul><p>some applications doesn’t need reliable delivery, it can use <strong>UDP</strong> (user datagram protocol).</p><ul><li>an alternative transport layer that bundles up application data and hands it to the network layer</li><li>it offers no delivery guarantees at all</li></ul><h3 id="application"><a class="markdownIt-Anchor" href="#application"></a> Application</h3><p>they have their own protocol to define the syntax and semantics of data flowing between two end points<br />(e.g. http, bit-torrent)</p><h3 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h3><img src = "../img/cs144/IP_is_thin.png" width="700px" height="350"/><img src = "../img/cs144/OSI-model.png" width="700px" height="350"/><h2 id="ip-service-model"><a class="markdownIt-Anchor" href="#ip-service-model"></a> IP Service model</h2><table><thead><tr><th>Property</th><th>behavior</th></tr></thead><tbody><tr><td>Datagram</td><td>Individually routed packets.</td></tr><tr><td>Unreliable</td><td>packet might be dropped</td></tr><tr><td>Best effort</td><td>only if necessary</td></tr><tr><td>Connectionless</td><td>No per-flow state.</td></tr></tbody></table><p><strong>IP is &quot;simple&quot;</strong></p><ul><li>faster, lower cost to build and maintain</li><li>The end-to-end principle</li><li>allows a variety of reliable (or unreliable) service to be built on top</li><li>make very few assumptions about link layer</li></ul><p><strong>IP Service Model</strong></p><ol><li>Tried to prevent packets looping forever<br />add a hop count field in the header of every datagram (<code>ttl</code>:time to live), start at a number like 128, decremented by every router passes through, when it reaches 0, IP think it be stuck in a loop then drop it.</li><li>will fragment packets if they are too long.<br />bc most links have a limit on the size of packets.(ethernet – 1500bytes)</li><li>uses a header checksum to reduce chances of delivering datagram to wrong destination.</li><li>allows for new version of IP<ul><li>IPv4     32 bit addresses</li><li>IPv6     128 bit addresses</li></ul></li><li>allows for new options to be added to header</li></ol><img src = "../img/cs144/IPv4-datagram.png"  width="500px" /><h2 id="life-of-a-packet"><a class="markdownIt-Anchor" href="#life-of-a-packet"></a> Life of a Packet</h2><h3 id="three-way-handshake"><a class="markdownIt-Anchor" href="#three-way-handshake"></a> three-way handshake</h3><ol><li><p>Client -----sends a synchronized message(同步信息)-----&gt; Server   (synchronize, <strong>SYN</strong>)</p></li><li><p>Server -----responds with a synchronized message and also acknowledges the client synchronize----&gt; Client   (synchronize and acknowledge, <strong>SYN/ACK</strong>)</p></li><li><p>Client -----responds by acknowledging the server synchronized ----&gt; Server   (acknowledge, <strong>ACK</strong>)</p></li></ol><p>IP addressed:  like computer addresses.<br />TCP port: tells which applications to deliver data to.</p><p>Web Server usually run on tcp port 80.</p><p><img src="../img/cs144/inside-the-stream.png" alt="" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>ComputerNetwork</tag>
      
      <tag>cs144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xcpc template</title>
    <link href="/xcpc-template/"/>
    <url>/xcpc-template/</url>
    
    <content type="html"><![CDATA[<h2 id="icpc模板"><a class="markdownIt-Anchor" href="#icpc模板"></a> icpc模板</h2><div class="row">    <embed src="../img/icpc-algorithm-template/catch22-algorithm-template.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="algorithm-template"><a class="markdownIt-Anchor" href="#algorithm-template"></a> algorithm-template</h1><blockquote><p>Competitive Programming template</p></blockquote><h2 id="basic-algorithm"><a class="markdownIt-Anchor" href="#basic-algorithm"></a> basic algorithm</h2><ul><li>[x] 双指针</li><li>[x] 离散化，去重</li><li>[x] 前缀和与差分</li><li>[x] 二分</li><li>[x] 单调栈</li><li>[x] 单调队列</li><li>[x] 尺取法</li><li>[ ] 归并排序，快速排序，第k小</li><li>[x] 树的中心</li><li>[x] 拓扑排序</li></ul><h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> math</h2><ul><li>[x] 素数，筛素数，素性测试， 反素数</li><li>[x] 质因数分解，预处理质因数</li><li>[x] 欧拉函数</li><li>[x] 组合数</li><li>[x] 拓展欧几里得，线性同余方程</li><li>[ ] 中国剩余定理</li><li>[x] 容斥原理</li><li>[x] 高斯消元，高斯异或</li><li>[x] 矩阵乘法</li><li>[ ] 博弈论，Nim游戏</li><li>[x] 莫比乌斯反演</li><li>[x] BSGS</li><li>[x] FFT</li><li>[ ] 生成函数</li><li>[ ] 线性基</li></ul><h2 id="date-strcture"><a class="markdownIt-Anchor" href="#date-strcture"></a> date strcture</h2><ul><li>[x] 并查集</li><li>[x] Sparse table</li><li>[x] Trie, 01Trie</li><li>[x] 树状数组</li><li>[x] 线段树，扫描线</li><li>[x] 树链剖分</li><li>[x] 可持久化线段树，kth number, 主席树</li><li>[ ] splay</li><li>[ ] 分块</li><li>[x] 莫队</li><li>[ ] 点分治</li><li>[ ] kdtree</li></ul><h2 id="graph"><a class="markdownIt-Anchor" href="#graph"></a> Graph</h2><ul><li>[x] Floyd</li><li>[x] bellman-ford, spfa，判负环</li><li>[x] dijkstra， 拆点</li><li>[x] 分层图最短路</li><li>[x] 差分约束</li><li>[x] 最小生成树 prim, kruskal</li><li>[x] 瓶颈生成树</li><li>[x] kruskal重构树</li><li>[x] lca</li><li>[x] 二分图匹配</li><li>[ ] 欧拉回路欧拉路径</li><li>[x] 强连通分量</li><li>[x] 2-sat</li><li>[ ] 网络流相关</li></ul><h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h2><ul><li>[x] 字符串hash</li><li>[x] KMP， 前缀函数</li><li>[x] Z-algorithm</li><li>[x] ac自动机</li><li>[x] SA</li><li>[x] SAM</li></ul><h2 id="dp"><a class="markdownIt-Anchor" href="#dp"></a> dp</h2><ul><li>[x] 01pack, 完全背包，多重背包及优化，分组背包</li><li>[x] 线性dp, LCS, LIS, 编辑距离</li><li>[x] 区间dp 字符串压缩</li><li>[x] 数位dp</li><li>[ ] 状压dp</li><li>[x] 树形dp</li><li>[x] 基环树dp</li><li>[x] 单调队列优化dp</li><li>[ ] 斜率优化dp</li></ul><h2 id="geometry"><a class="markdownIt-Anchor" href="#geometry"></a> Geometry</h2><ul><li>[ ] 常用模板</li><li>[ ] 二维凸包</li></ul><blockquote><p>github地址 <a href="https://github.com/caaatch22/algorithm-template">https://github.com/caaatch22/algorithm-template</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>icpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
